plugins {
    id "base"
    id "war"
    id "idea"
    id "de.undercouch.download" version "3.2.0"
    id "java"
    id "jacoco"
}

group "$groupName"

repositories {
    mavenCentral()
}

/**
 * Set sources for integration tests
 */
sourceSets {
    main {
        resources {
            exclude 'env'
        }
    }
    test {
        java.srcDir 'src/test/unit/java'
        resources.srcDir 'src/test/unit/resources'
    }
    integration {
        java.srcDir 'src/test/integration/java'
        resources.srcDir 'src/test/integration/resources'
        compileClasspath += main.output + test.output
        runtimeClasspath += main.output + test.output
    }
}
configurations {
    integrationCompile.extendsFrom testCompile
    integrationRuntime.extendsFrom testRuntime
}

/**
 * Idea config
 */
idea {
    module {
        testSourceDirs = [
                file('src/test/integration/java'),
                file('src/test/unit/java')
        ]
        scopes.TEST.plus += [configurations.integrationCompile]
    }
}


/**
 * Jacoco plugin config
 */
jacocoTestReport {
    reports {
        xml.enabled true
        html.enabled true
    }
}

/**
 * Compile dependencies
 */
dependencies {
    compile(
            "com.fasterxml.jackson.core:jackson-databind:$jaksonJsonVersion",
            "com.fasterxml.jackson.datatype:jackson-datatype-jaxrs:$jaksonJsonVersion",
            "com.fasterxml.jackson.jaxrs:jackson-jaxrs-json-provider:$jaksonJsonVersion",
            "com.fasterxml.jackson.datatype:jackson-datatype-jdk8:$jaksonJsonVersion",
            "com.fasterxml.jackson.datatype:jackson-datatype-jsr310:$jaksonJsonVersion",
            "org.apache.logging.log4j:log4j-core:$log4jVersion",
            "org.apache.logging.log4j:log4j-api:$log4jVersion",
            "org.apache.logging.log4j:log4j-slf4j-impl:$log4jVersion",

            "org.slf4j:slf4j-api:$slf4jApiVersion",
            "org.reflections:reflections:$reflectionsVersion",
            "com.lmax:disruptor:$disruptorVersion",
            "mysql:mysql-connector-java:$mysqlVersion"
    )
    providedCompile(
            "javax:javaee-api:$javaEEApiVersion",
    )
    testCompileOnly "javax:javaee-api:$javaEEApiVersion"
    testCompile(
            "org.glassfish.jersey.core:jersey-client:$jerseyVersion",
            "org.apache.logging.log4j:log4j-core:$log4jVersion",
            "org.apache.logging.log4j:log4j-api:$log4jVersion",
            "org.powermock:powermock-module-junit4:$powerMockVersion",
            "org.powermock:powermock-module-junit4-rule:$powerMockVersion",
            "org.powermock:powermock-api-mockito:$powerMockVersion",
            "org.powermock:powermock:$powerMockVersion",
            "org.mockito:mockito-core:$mockitoVersion",
            "junit:junit:$jUnitVersion"
    )
    /// dependencies for itest
    integrationCompile(
             "com.google.guava:guava:$guavaVersion",
            "fish.payara.extras:payara-embedded-all:$pmv",
            "org.jboss.arquillian.junit:arquillian-junit-container:$junitArquillian",
            "org.jboss.arquillian.container:arquillian-glassfish-embedded-3.1:$glassfishEmbedded",
            "org.eu.ingwar.tools:arquillian-suite-extension:$arquillianSuiteVersion",
    )
}

/**
 * Configs
 */
ext {
    dockerName = "${group}/${war.baseName}:${version}_${env}"
    dockerStartupName = "${war.baseName}_${version}_${port}"
    warName = "${war.baseName}-$version"
    dockerDir = "${project.buildDir}/docker"
    warDir = "${project.buildDir}/libs"
    awsEBSBucket = "elasticbeanstalk-$awsRegion-$awsId"
    awsS3File = "Dockerrun.aws.${rootProject.name}_${env}_${version}.json"
    awsVersionLabel = "${rootProject.name}_${env}_${version}"
    awsEBSDeployRegion = "${awsRegion}"
}

/**
 * Download payara micro
 */
task downloadPayaraMicro {
    doFirst {
        download {
            src "http://central.maven.org/maven2/fish/payara/extras/payara-micro/${pmv}/payara-micro-${pmv}.jar"
            dest "$projectDir/payara-micro.jar"
        }
    }
}

/**
 * Build configuration environment
 */
task buildConfig(type: Copy) {
    from("src/main/resources/env/${env}/")
    doFirst {
        println("#### BUILD " + env)
    }
    into sourceSets.main.output.resourcesDir
    doLast {
        Properties props = new Properties()
        File propsFile = new File("${sourceSets.main.output.resourcesDir}/config.properties")
        props.load(propsFile.newDataInputStream())
        props.setProperty("version", version.toString())
        props.setProperty("applicationName", rootProject.name)
        props.store(propsFile.newWriter(), null)
        if (props.getProperty("aws.deploy.region") != null) {
            project.ext.set("awsEBSDeployRegion", props.getProperty("aws.deploy.region"))
            project.ext.set("awsEBSBucket", "elasticbeanstalk-$awsEBSDeployRegion-$awsId")
        }
        mkdir dockerDir
    }
}

tasks.compileJava.dependsOn buildConfig
tasks.war.dependsOn buildConfig
// REQUIRED
war {
    webInf { from sourceSets.main.output.resourcesDir.toString() + "/WEB-INF" }
}
/**
 * Remove docker image
 */
task removeDocker(type: Exec) {
    commandLine "docker", "rmi", "--force", "${dockerName}"
}

/**
 *  Prepare docker files for buildDocker
 */
task prepareDockerFiles(type: Copy, dependsOn: war) {
    println("$dockerDir/${warName}.war")
    from("$warDir/${warName}.war") {
        rename "${warName}.war", "app.war"
    }
    from file("Dockerfile")
    into dockerDir
    outputs.dir dockerDir
}
/**
 * Bake docker image
 */
task buildDocker(type: Exec, dependsOn: prepareDockerFiles) {
    standardOutput = new ByteArrayOutputStream()
    executable "docker"
    args = ["build", "-t", "${dockerName}", "${dockerDir}"]
    ext.output = {
        return 0
    }
    doFirst {
        println("DOCKER DIR $dockerDir")
    }
    doLast {
        println(standardOutput.toString())
    }
    outputs.upToDateWhen {
        return !tasks.prepareDockerFiles.getDidWork()
    }
}
/**
 * Start docker container
 */
task startDocker(type: Exec, dependsOn: buildDocker) {
    commandLine "docker", "run", "-d", "-p", "${port}:${payaraPort}", "--name", "${dockerStartupName}", "${dockerName}"
    doFirst {
        println("Docker compose start")
        tasks.dockerCompose.execute()
    }
}

/**
 * Docker remove
 */
task stopDocker(type: Exec) {
    commandLine "docker", "rm", "-f", "${dockerStartupName}"
    doLast {
        println("Docker compose down")
        tasks.dockerComposeDown.execute()
    }
}

/**
 *  Remove docker image
 */
task dockerRemoveImage(type: Exec) {
    standardOutput = new ByteArrayOutputStream()
    commandLine "docker", "rmi", "${dockerName}", "--force"
    ext.output = {
        return 0
    }
}

/**
 *  Docker compose start containers
 */
task dockerCompose(type: Exec) {
    commandLine "docker-compose", "up", "-d"
    doLast {
        Integer waitInSeconds = Integer.parseInt(dockerComposeWaitInSeconds)
        printf("Waiting %d seconds for docker-compose to start\n", waitInSeconds)
        Thread.sleep(waitInSeconds * 1000)
    }
}
/**
 *  Docker compose stop containers
 */
task dockerComposeDown(type: Exec) {
    commandLine "docker-compose", "down"
}

/**
 * Start payara micro server
 */
task startServer(type: Exec, dependsOn: war) {
    commandLine "java", "-jar", "./payara-micro.jar", "--deploy", "$warDir/${warName}.war", "--noCluster", "true"
    doFirst {
        if (!file("./payara-micro.jar").exists()) {
            tasks.downloadPayaraMicro.execute()
        }
    }
}

/**
 * Testing unit tests configuration
 */
test {
    scanForTestClasses = true
    include '**/*Test.class'
    maxParallelForks = 4
    testLogging {
        showStandardStreams = true
        exceptionFormat "full"
        events = ["started", "passed", "skipped", "failed", "standard_out", "standard_error"]
        showExceptions = true
        showStackTraces = true
    }
    afterTest { desc, result ->
        println "Executing test ${desc.name} [${desc.className}] with result: ${result.resultType}"
    }
}

/**
 * Integration testing configuration
 */
task itest(type: Test) {
    System.setProperty "http.port", port
    scanForTestClasses = true
    include '**/*Test.class'
    maxParallelForks = 1
    testLogging {
        showStandardStreams = true
        exceptionFormat "full"
        events = ["started", "passed", "skipped", "failed", "standard_out", "standard_error"]
        showExceptions = true
        showStackTraces = true
    }
    afterTest { desc, result ->
        println "Executing test ${desc.name} [${desc.className}] with result: ${result.resultType}"
    }
    outputs.upToDateWhen { false }
    doFirst {
        println("STARTING IT TEST")
    }
    jacoco {
        destinationFile = file("$buildDir/jacoco/itest.exec")
    }
    // set class path and pass args
    systemProperties = System.properties
    testClassesDir = sourceSets.integration.output.classesDir
    classpath = sourceSets.integration.runtimeClasspath
}

/**
 * Json
 */
import groovy.json.JsonBuilder
import groovy.json.JsonSlurper

/**
 * Create ebs version
 */
task createEBSVersion {
    ext.ebsVersionName = "Dockerrun.aws.json"
    doLast {
        def json = new JsonSlurper().parse(
                """
            {
              "AWSEBDockerrunVersion": "1",
              "Image": {
                "Name": null,
                "Update": "true"
              },
              "Ports": [
                {
                  "HostPort": 80,
                  "ContainerPort": ${payaraPort}
                }
              ]
            }
            """.toCharArray()
        )
        json.Image.Name = "${awsECR}:${version}_${env}"
        File dockerRun = file(ebsVersionName)
        dockerRun.write(new JsonBuilder(json).toPrettyString())
    }
}

tasks.createEBSVersion.mustRunAfter buildDocker
/**
 * Login to aws
 */
task loginToAws(type: Exec) {
    standardOutput = new ByteArrayOutputStream()
    commandLine "aws", "ecr", "get-login", "--region", "$awsRegion"
    doLast {
        List<String> commands = standardOutput.toString().split("\\s")

        // temp bugfix for aws ecr get-login result
        commands.removeAt(commands.size() - 3) // remove -e
        commands.removeAt(commands.size() - 2) // remove none

        // println(commands.toString())

        String command = commands.remove(0)
        exec {
            executable command
            args commands
        }
    }
}

/**
 * Check ebs version
 */
task checkEBSVersion(type: Exec) {
    standardOutput = new ByteArrayOutputStream()
    executable "aws"
    doFirst {
        args = [
                "elasticbeanstalk",
                "describe-application-versions",
                "--application-name",
                "$awsEBSApp",
                "--version-label",
                "$awsVersionLabel",
                "--region",
                "$awsEBSDeployRegion"
        ]
        println("checkEBSVersion ARGS: " + args.toString())
        println("CHECK $awsEBSApp -> $awsVersionLabel -> $awsEBSDeployRegion")
    }
    doLast {
        byte[] bytes = standardOutput.toByteArray()
        println("VERSIONS")
        println(standardOutput.toString())
        def json = new JsonSlurper().parse(bytes)
        if (json != null && json.ApplicationVersions != null && json.ApplicationVersions.size() > 0) {
            throw new Error("VERSION EXISTS!!!")
        }
    }
    ext.output = {
        return 0
    }
}

tasks.checkEBSVersion.mustRunAfter createEBSVersion
/**
 * Create docker build and ecr tags
 */
task createECRDockerTags(type: Exec, dependsOn: [buildDocker, createEBSVersion, checkEBSVersion]) {
    commandLine "docker", "tag", "$dockerName", "$awsECR:${version}_${env}"
    doFirst {
        if (env.equals("prod")) {
            exec {
                commandLine "docker", "tag", "$dockerName", "$awsECR:latest"
            }
        }
    }
}
/**
 * Create s3 ECR version
 */
task createS3ECRVersion(type: Exec, dependsOn: createECRDockerTags) {
    executable "aws"
    doFirst {
        args = [
                "s3",
                "cp",
                "./$awsS3File",
                "s3://$awsEBSBucket/$awsS3File",
                "--region",
                "$awsEBSDeployRegion"
        ]
        println("createS3ECRVersion ARGS: " + args.toString())
    }
}

tasks.createS3ECRVersion.mustRunAfter build
/**
 * publish to ecr
 */
task publishToECR(type: Exec, dependsOn: [clean, createS3ECRVersion, loginToAws]) {
    executable "aws"
    doFirst {
        args = [
                "elasticbeanstalk",
                "create-application-version",
                "--application-name",
                "$awsEBSApp",
                "--version-label",
                "$awsVersionLabel",
                "--source-bundle",
                "S3Bucket=$awsEBSBucket,S3Key=$awsS3File",
                "--region",
                "$awsEBSDeployRegion"
        ]
        println("publishToECR ARGS: " + args.toString())
        exec {
            commandLine "docker", "push", "$awsECR:${version}_${env}"
        }
        if (env.equals("prod")) {
            exec {
                commandLine "docker", "push", "$awsECR:latest"
            }
        }
    }
}
